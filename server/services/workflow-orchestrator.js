const AgentExecutor = require('./agent-executor');
const ArtifactLineage = require('./artifact-lineage');
const { v4: uuidv4 } = require('uuid');
const path = require('path');
// Import models properly
const { Workflow, Artifact, Project } = require('../models/index');
const fs = require('fs').promises;
const crypto = require('crypto');

class WorkflowOrchestrator {
  constructor(workspaceRoot, socketio, options = {}) {
    this.workspaceRoot = workspaceRoot;
    this.socketio = socketio;
    this.options = options || {};
    this.autoStart = this.options.autoStart !== false; // default true
    this.agents = new Map();
    this.workflows = new Map();
    this.taskQueue = [];
    this.completedWorkflows = [];
    
    // Initialize artifact lineage system
    this.artifactLineage = new ArtifactLineage();
    
    // Initialize autonomous agents with specialized capabilities
    this.initializeAgents();
    
    // Start workflow processor and artifact reconciler if autoStart enabled
    if (this.autoStart) {
      this.startWorkflowProcessor();
      // Start artifact reconciliation loop for deferred DB persists
      this.startArtifactReconciler();
    }
    
    console.log('âœ… Workflow Orchestrator initialized with artifact lineage tracking');
  }

  startArtifactReconciler() {
    // Try to persist pending artifact records every 20 seconds
    this.artifactReconcilerInterval = setInterval(async () => {
      if (!this.pendingArtifactPersist || this.pendingArtifactPersist.length === 0) return;
      const pending = this.pendingArtifactPersist.slice();
      for (const entry of pending) {
        try {
          const wf = await Workflow.findByPk(entry.workflowId).catch(() => null);
          if (!wf) continue; // still not present

          // attempt to persist - resolve project id and handle unique sha collisions
          try {
            const wfRow = await Workflow.findByPk(entry.workflowId).catch(() => null);
            let projectId = wfRow && wfRow.metadata && wfRow.metadata.project_id ? wfRow.metadata.project_id : null;
            if (!projectId) {
              let p = await Project.findOne().catch(() => null);
              if (!p) {
                p = await Project.create({ name: 'Autogenerated', description: 'Auto project for artifact persistence', owner_id: 1, status: 'active' });
              }
              projectId = p.id;
            }

            const sha = entry.lineageData.checksum || '';
            let persisted = false;
            if (!sha || sha.length === 0) {
              console.warn('[DB] Reconcile: missing checksum, skipping create for now', entry.lineageData.relativePath || entry.lineageData.absolutePath || entry.lineageData.name);
            } else {
              try {
                await Artifact.create({
                  project_id: projectId || entry.workflowId,
                  path: entry.lineageData.relativePath || entry.lineageData.absolutePath || entry.lineageData.name,
                  sha256: sha,
                  bytes: entry.lineageData.fileSize || 0,
                  produced_by_task: entry.lineageData.taskId || null
                });
                persisted = true;
                console.log('[DB] Reconcile: persisted artifact for', entry.workflowId);
              } catch (err) {
                const parentMsg = err && err.parent && err.parent.message && err.parent.message.toLowerCase ? err.parent.message.toLowerCase() : '';
                const isUnique = (err && err.name === 'SequelizeUniqueConstraintError') || (err && err.message && err.message.toLowerCase && err.message.toLowerCase().includes('unique')) || parentMsg.includes('unique');
                if (isUnique && sha) {
                  const existing = await Artifact.findOne({ where: { sha256: sha } }).catch(() => null);
                  if (existing) {
                    console.log('[DB] Reconcile: artifact exists with same sha, linking existing', existing.id);
                    persisted = true; // treat as persisted for reconciliation purposes
                  } else {
                    console.warn('[DB] Reconcile: unique constraint but no existing artifact found; will retry later', err && err.message);
                  }
                } else if (err && err.name === 'SequelizeForeignKeyConstraintError' || (err && err.message && err.message.toLowerCase && err.message.toLowerCase().includes('foreign key'))) {
                  console.warn('[DB] Reconcile: FK constraint encountered, will retry later', err && err.message);
                } else {
                  console.warn('[DB] Reconciliation attempt failed:', err && err.message);
                }
              }
            }
          } catch (e) {
            console.warn('[DB] Could not resolve project for artifact persist, will attempt with fallback later:', e && e.message);
          }

          // remove from pending list only if persisted/linked
          if (typeof persisted !== 'undefined' && persisted) {
            this.pendingArtifactPersist = this.pendingArtifactPersist.filter(p => p !== entry);
            console.log('[DB] Reconciled and persisted deferred artifact for workflow', entry.workflowId);
          } else {
            console.log('[DB] Reconcile left pending artifact for workflow', entry.workflowId);
          }
        } catch (e) {
          // ignore and keep for next attempt
          console.warn('[DB] Reconciliation attempt failed:', e && e.message);
        }
      }
    }, 20 * 1000);
  }

  // Expose a one-shot reconcile method for tests / on-demand reconciliation
  async reconcilePendingArtifactsOnce() {
    if (!this.pendingArtifactPersist || this.pendingArtifactPersist.length === 0) return 0;
    const pending = this.pendingArtifactPersist.slice();
    let persistedCount = 0;
    for (const entry of pending) {
      try {
        const { workflowId, lineageData, trackedArtifactId } = entry;
        const wf = await Workflow.findByPk(workflowId).catch(() => null);
        if (!wf) continue; // still not present

        // resolve a safe project id to satisfy FK
        let projectId = null;
        if (wf && wf.metadata && wf.metadata.project_id) projectId = wf.metadata.project_id;
        if (!projectId) {
          let p = await Project.findOne();
          if (!p) {
            p = await Project.create({ name: 'Autogenerated', description: 'Auto project for artifact persistence', owner_id: 1, status: 'active' });
          }
          projectId = p.id;
        }

        const sha = lineageData.checksum || '';
        if (!sha || sha.length === 0) {
          console.warn('[DB] Reconcile once: missing checksum, skipping', lineageData.relativePath || lineageData.absolutePath || lineageData.name);
          continue;
        }

        try {
          const created = await Artifact.create({
            project_id: projectId || entry.workflowId,
            path: lineageData.relativePath || lineageData.absolutePath || lineageData.name,
            sha256: sha,
            bytes: lineageData.fileSize || 0,
            produced_by_task: lineageData.taskId || null
          });

          console.log('[Reconciler] Persisted pending artifact to DB:', created.id);

          // attach DB id back into tracked artifact and update workflow.artifacts
          if (trackedArtifactId) {
            const tracked = this.artifactLineage.getArtifactWithLineage(trackedArtifactId);
            if (tracked) {
              tracked.dbArtifactId = created.id;
              try {
                const wfArtifacts = wf.artifacts || [];
                const found = wfArtifacts.find(a => a.id === tracked.id || a.lineageId === tracked.id || a.trackedId === tracked.id);
                if (found) {
                  found.dbArtifactId = created.id;
                } else {
                  wfArtifacts.push({ id: created.id, lineageId: tracked.id, dbArtifactId: created.id });
                }
                await Workflow.update({ artifacts: wfArtifacts }, { where: { id: wf.id } }).catch(() => null);
              } catch (uerr) {
                console.warn('[Reconciler] Failed to update workflow.artifacts with db id:', uerr && uerr.message);
              }
            }
          }

          // remove from pending
          this.pendingArtifactPersist = this.pendingArtifactPersist.filter(p => p !== entry);
          persistedCount++;
        } catch (err) {
          const parentMsg = err && err.parent && err.parent.message && err.parent.message.toLowerCase ? err.parent.message.toLowerCase() : '';
          const isUnique = (err && err.name === 'SequelizeUniqueConstraintError') || (err && err.message && err.message.toLowerCase && err.message.toLowerCase().includes('unique')) || parentMsg.includes('unique');
          if (isUnique && sha) {
            const existing = await Artifact.findOne({ where: { sha256: sha } }).catch(() => null);
            if (existing) {
              console.log('[Reconciler] Pending artifact matches existing DB artifact, linking id', existing.id);
              if (trackedArtifactId) {
                const tracked = this.artifactLineage.getArtifactWithLineage(trackedArtifactId);
                if (tracked) {
                  tracked.dbArtifactId = existing.id;
                }
              }
              // update workflow.artifacts array
              try {
                const wfArtifacts = wf.artifacts || [];
                const found = wfArtifacts.find(a => a.id === existing.id || a.dbArtifactId === existing.id || a.lineageId === trackedArtifactId);
                if (!found) wfArtifacts.push({ id: existing.id, dbArtifactId: existing.id, lineageId: trackedArtifactId });
                await Workflow.update({ artifacts: wfArtifacts }, { where: { id: wf.id } }).catch(() => null);
              } catch (uerr) {
                console.warn('[Reconciler] Failed to update workflow.artifacts after linking existing artifact:', uerr && uerr.message);
              }
              // remove pending entry
              this.pendingArtifactPersist = this.pendingArtifactPersist.filter(p => p !== entry);
              persistedCount++;
              continue;
            }
          }

          console.warn('[Reconciler] Failed to persist pending artifact, will retry later:', err && err.message);
        }
      } catch (e) {
        console.error('[Reconciler] Unexpected error while reconciling pending artifacts:', e && e.stack);
      }
    }
    return persistedCount;
  }

  initializeAgents() {
    const agentConfigs = [
      {
        name: 'Alex',
        role: 'Project Manager', 
        specializations: ['planning', 'coordination', 'task-breakdown', 'project-management'],
        workspaceDir: path.join(this.workspaceRoot, 'alex-workspace')
      },
      {
        name: 'Nova',
        role: 'Frontend Developer',
        specializations: ['react', 'typescript', 'html', 'css', 'frontend', 'ui-components'],
        workspaceDir: path.join(this.workspaceRoot, 'nova-workspace')
      },
      {
        name: 'Zephyr', 
        role: 'Backend Developer',
        specializations: ['nodejs', 'apis', 'databases', 'backend', 'server-infrastructure'],
        workspaceDir: path.join(this.workspaceRoot, 'zephyr-workspace')
      },
      {
        name: 'Pixel',
        role: 'Designer',
        specializations: ['ui-design', 'css', 'styling', 'branding', 'visual-design'],
        workspaceDir: path.join(this.workspaceRoot, 'pixel-workspace')
      },
      {
        name: 'Cipher',
        role: 'Security Engineer', 
        specializations: ['security', 'authentication', 'validation', 'compliance'],
        workspaceDir: path.join(this.workspaceRoot, 'cipher-workspace')
      },
      {
        name: 'Sage',
        role: 'DevOps Engineer',
        specializations: ['deployment', 'infrastructure', 'monitoring', 'ci-cd'],
        workspaceDir: path.join(this.workspaceRoot, 'sage-workspace')
      }
    ];

    for (const config of agentConfigs) {
      const executor = new AgentExecutor(config.name, config.workspaceDir, this.socketio);
      this.agents.set(config.name, {
        executor,
        config,
        queueDepth: 0,
        averageTaskTime: this.getHistoricalAverage(config.name),
        availability: 'available'
      });
    }

    console.log(`âœ… Initialized ${this.agents.size} autonomous agents`);
  }

  async createWorkflow(userDirective, briefContext = null) {
    const workflowId = uuidv4();
    const startTime = Date.now();

    console.log(`[WORKFLOW:${workflowId}] Creating workflow for directive: "${userDirective}"`);
    
    if (briefContext) {
      console.log(`[WORKFLOW:${workflowId}] Using brief context: ${briefContext.projectType} - ${briefContext.scope} - ${briefContext.timeline}`);
    }

  // Enhanced task decomposition with brief context
  // If a completed brief object is passed in (from BriefManager), prefer its suggested manager
  const tasks = await this.decomposeDirective(userDirective, briefContext);
    
    // Calculate realistic time estimates
    const estimates = this.calculateTimeEstimates(tasks);
    
    const workflow = {
      id: workflowId,
      directive: userDirective,
      status: 'planned',
      // tasks will be set below depending on manager brief gating
      tasks: [],
      estimates,
      startTime,
      progress: {
        completed: 0,
        total: 0,
        percentage: 0
      },
      artifacts: [],
      metadata: {}
    };

  // Save to both memory and database
  this.workflows.set(workflowId, workflow);
    
    try {
      // Persist to database
      // Ensure there's a Project record to attach artifacts to
      let projectId = null;
      try {
        // Create a lightweight project record representing this workflow
        const project = await Project.create({
          name: `Workflow - ${workflowId}`,
          description: `Auto-generated project for workflow ${workflowId}`,
          owner_id: 1,
          status: 'active',
          file_system_path: this.workspaceRoot
        });
        projectId = project.id;
      } catch (e) {
        console.warn('[WORKFLOW] Could not create project for workflow:', e && e.message);
        // fallback: find any existing project
        const p = await Project.findOne().catch(() => null);
        if (p) projectId = p.id;
      }

      await Workflow.create({
        id: workflowId,
        directive: userDirective,
        status: 'planned',
        start_time: new Date(startTime),
        tasks: tasks,
        estimates: estimates,
        progress: workflow.progress,
        artifacts: [],
        metadata: { project_id: projectId }
      });

      console.log(`[WORKFLOW:${workflowId}] Persisted to database with project ${projectId}`);
    } catch (error) {
      console.error(`[WORKFLOW:${workflowId}] Failed to persist to database:`, error);
    }
    
    // Emit workflow creation to Board Room (guarded for test contexts without socketio)
    if (this.socketio && typeof this.socketio.emit === 'function') {
      this.socketio.emit('workflow-created', {
      workflowId,
      directive: userDirective,
      tasks: tasks.map(t => ({
        id: t.id,
        title: t.title,
        assignedAgent: t.assignedAgent,
        status: t.status,
        estimatedDuration: t.estimatedDuration
      })),
      estimates
      });
    } else {
      console.log(`[WORKFLOW:${workflowId}] socketio not available, skipping workflow-created emit`);
    }

    // Add tasks to execution queue
    // If there is a manager brief gating the workflow, pause scheduling of specialist tasks until approval
    // Manager brief tasks will have type 'manager_brief' and a special metadata.briefId
    const managerBriefTasks = tasks.filter(t => t.type === 'manager_brief');
    if (managerBriefTasks && managerBriefTasks.length > 0) {
      // When manager brief gating exists, only persist and queue the manager brief tasks now
      workflow.tasks = managerBriefTasks.slice();
      workflow.progress.total = workflow.tasks.length;
      workflow.metadata.requiresManagerApproval = true;

      this.queueTasks(managerBriefTasks, workflowId);

      // Store remaining tasks to be scheduled after approval (do not persist them yet to avoid duplication)
      const pending = tasks.filter(t => t.type !== 'manager_brief');
      workflow._pendingAfterApproval = pending;
      console.log(`[WORKFLOW:${workflowId}] Paused ${pending.length} tasks until manager brief approval`);
    } else {
      workflow.tasks = tasks;
      workflow.progress.total = workflow.tasks.length;
      this.queueTasks(tasks, workflowId);
    }

    return { workflowId, workflow };
  }

  async decomposeDirective(directive, briefContext = null) {
    const tasks = [];
    
    // Enhanced AI-driven task decomposition with brief context
    let projectType = 'general';
    let scope = 'basic';
    let timeline = 'standard';
    let keyFeatures = [];
    let targetUsers = 'general';
    let suggestedAgents = ['Alex', 'Nova'];
    
    if (briefContext) {
      projectType = briefContext.projectType || 'general';
      scope = briefContext.scope || 'basic';
      timeline = briefContext.timeline || 'standard';
      keyFeatures = briefContext.keyFeatures || [];
      targetUsers = briefContext.targetUsers || 'general';
      suggestedAgents = briefContext.suggestedAgents || ['Alex', 'Nova'];
      
      console.log(`[WORKFLOW] Brief context applied: ${projectType}, ${scope}, ${timeline}`);
      console.log(`[WORKFLOW] Key features: ${keyFeatures.join(', ')}`);
      console.log(`[WORKFLOW] Suggested agents: ${suggestedAgents.join(', ')}`);
    }

    // If directive requests creation of an .md document and a specific agent
    // was requested explicitly, build a compact plan that ensures the
    // requested agent is the creator of the artifact (no silent substitution).
    try {
      const lower = directive.toLowerCase();
      const mentionsCreate = lower.includes('create') || lower.includes('put it in') || lower.includes('make');
      // Consider variations: ".md", "markdown", "md document", or standalone " md "
      const mentionsMd = lower.includes('.md') || lower.includes('markdown') || lower.includes('md document') || (/\bmd\b/.test(lower)) || (briefContext && briefContext.filename && briefContext.filename.toLowerCase().endsWith('.md'));

      // Detect explicit agent mention in directive text (e.g., "have Sage create ...")
      let explicitAgentFromDirective = null;
      try {
        for (const agentName of this.agents.keys()) {
          if (!agentName) continue;
          if (lower.includes(agentName.toLowerCase())) {
            explicitAgentFromDirective = agentName;
            break;
          }
        }
      } catch (e) {
        // ignore detection errors
      }

      const explicitRequestedAgent = (briefContext && briefContext.agentExplicit && briefContext.requestedAgent) ? briefContext.requestedAgent : explicitAgentFromDirective;

      if (explicitRequestedAgent && mentionsCreate && mentionsMd) {
        const requested = explicitRequestedAgent;

        // Determine manager (prefer requested if makes sense)
        const manager = this.selectManagerForDirective(directive, briefContext) || requested || 'Alex';

        // Choose specialist for file creation (markdown -> Nova by default)
        const filename = (briefContext && briefContext.filename) ? briefContext.filename : (lower.includes('about-me') || lower.includes('about me') ? 'ABOUT_ME.md' : 'ABOUT_ME.md');
        const specialistForMd = 'Nova';
        const createAssignee = (manager === requested && requested === 'Sage') ? specialistForMd : requested;

        // Manager brief task that must be approved before specialists proceed
        const managerBriefFilename = `MANAGER_BRIEF.md`;
        const managerBriefContent = `# Manager Brief\n\nDirective: ${directive}\n\nUnderstanding:\n- ...\n\nAssumptions:\n- ...\n\nRisks:\n- ...\n\nInitial Plan:\n1. ...\n2. ...\n\nNotes: This brief was authored by ${manager}.`;

        const managerBriefTask = {
          id: uuidv4(),
          title: 'Manager Brief: Summary, Assumptions, Risks, Plan',
          description: `Manager (${manager}) will author a short brief for: ${directive}`,
          assignedAgent: manager,
          // Use a distinct task type so the orchestrator can detect manager briefs
          type: 'manager_brief',
          // Keep create-file style fields so the executor can create the file when run
          fileName: managerBriefFilename,
          content: managerBriefContent,
          briefMeta: {
            directive,
            filename: filename
          },
          dependencies: [],
          status: 'pending',
          estimatedDuration: 8000
        };

        // File creation task - assigned to specialist (e.g., Nova) and depends on manager brief approval
        const createTask = {
          id: uuidv4(),
          title: `Create ${filename}`,
          description: `Create ${filename} as requested in the directive (specialist: ${createAssignee})`,
          assignedAgent: createAssignee,
          type: 'create_file',
          fileName: filename,
          // Initial content includes provenance; final content may be edited later in Workers
          content: `# About Me\n\nThis document was created by ${createAssignee} in response to directive:\n\n> ${directive}\n\n(Please review and edit as needed.)\n`,
          dependencies: [managerBriefTask.id],
          status: 'pending',
          estimatedDuration: 8000
        };

        // Optional QA/lint task to run only if requested by briefContext (default: not run)
        const qaTask = {
          id: uuidv4(),
          title: `Optional Lint/QA for ${filename}`,
          description: 'Run lint/qa checks on created document (requires approval)',
          assignedAgent: 'Cipher',
          commands: [],
          dependencies: [createTask.id],
          status: 'pending',
          estimatedDuration: 5000,
          optional: true
        };

        tasks.push(managerBriefTask, createTask, qaTask);
        return tasks;
      }
    } catch (err) {
      console.warn('Error building explicit create-file plan:', err && err.message);
    }
    
    // Intelligent task decomposition based on project type and brief context
    if (projectType === 'website' || directive.toLowerCase().includes('landing page') || directive.toLowerCase().includes('website')) {
      return this.createWebsiteWorkflow(directive, briefContext);
    } else if (projectType === 'dashboard' || directive.toLowerCase().includes('dashboard') || directive.toLowerCase().includes('monitoring')) {
      return this.createDashboardWorkflow(directive, briefContext);
    } else if (projectType === 'fullstack' || directive.toLowerCase().includes('app') || directive.toLowerCase().includes('application')) {
      return this.createFullstackWorkflow(directive, briefContext);
    } else if (directive.toLowerCase().includes('dashboard') || directive.toLowerCase().includes('monitoring')) {
      const task1 = {
        id: uuidv4(),
        title: 'Create project structure and setup',
        description: 'Initialize workspace, create directory structure, and setup package.json',
        assignedAgent: 'Alex',
        commands: [
          'mkdir -p dashboard-project/src/components dashboard-project/public',
          'cd dashboard-project && npm init -y',
          'cd dashboard-project && npm install react react-dom @types/react @types/react-dom typescript',
          'echo "# AI Agent Dashboard\\n\\nReal-time monitoring dashboard for autonomous AI agents." > dashboard-project/README.md'
        ],
        dependencies: [],
        status: 'pending',
        estimatedDuration: 45000 // 45 seconds
      };

      const task2 = {
        id: uuidv4(), 
        title: 'Design dashboard layout and components',
        description: 'Create responsive dashboard layout with metrics cards and charts',
        assignedAgent: 'Pixel',
        commands: [
          'cd dashboard-project && mkdir -p src/styles',
          'cat > dashboard-project/src/styles/dashboard.css << EOF\n.dashboard {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n  gap: 20px;\n  padding: 20px;\n}\n\n.metric-card {\n  background: white;\n  border-radius: 8px;\n  padding: 24px;\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n}\nEOF'
        ],
        dependencies: [task1.id],
        status: 'pending',
        estimatedDuration: 60000 // 60 seconds
      };

      const task3 = {
        id: uuidv4(),
        title: 'Implement React dashboard components',
        description: 'Build responsive dashboard with real-time metrics display',
        assignedAgent: 'Nova',
        commands: [
          'cd dashboard-project/src && cat > App.js << EOF\nimport React, { useState, useEffect } from "react";\nimport "./styles/dashboard.css";\n\nfunction App() {\n  const [metrics, setMetrics] = useState({\n    activeAgents: 0,\n    tasksCompleted: 0,\n    avgResponseTime: 0\n  });\n\n  useEffect(() => {\n    // Simulate real-time data updates\n    const interval = setInterval(() => {\n      setMetrics({\n        activeAgents: Math.floor(Math.random() * 6) + 1,\n        tasksCompleted: Math.floor(Math.random() * 100) + 50,\n        avgResponseTime: Math.floor(Math.random() * 500) + 100\n      });\n    }, 2000);\n    return () => clearInterval(interval);\n  }, []);\n\n  return (\n    <div className="dashboard">\n      <div className="metric-card">\n        <h3>Active Agents</h3>\n        <p className="metric-value">{metrics.activeAgents}</p>\n      </div>\n      <div className="metric-card">\n        <h3>Tasks Completed</h3>\n        <p className="metric-value">{metrics.tasksCompleted}</p>\n      </div>\n      <div className="metric-card">\n        <h3>Avg Response Time</h3>\n        <p className="metric-value">{metrics.avgResponseTime}ms</p>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\nEOF'
        ],
        dependencies: [task2.id],
        status: 'pending',
        estimatedDuration: 120000 // 120 seconds
      };

      const task4 = {
        id: uuidv4(),
        title: 'Setup build and deployment',
        description: 'Configure build process and prepare for deployment',
        assignedAgent: 'Sage',
        commands: [
          'cd dashboard-project && npm run build',
          'cd dashboard-project && echo "Dashboard build completed successfully" > build-log.txt'
        ],
        dependencies: [task3.id],
        status: 'pending',
        estimatedDuration: 30000 // 30 seconds
      };

      tasks.push(task1, task2, task3, task4);

    } else if (directive.toLowerCase().includes('landing page') || directive.toLowerCase().includes('website')) {
      // Landing page workflow
      const task1 = {
        id: uuidv4(),
        title: 'Create landing page structure',
        description: 'Setup HTML structure and basic styling for landing page',
        assignedAgent: 'Nova',
        commands: [
          'mkdir -p landing-page/assets/css landing-page/assets/js',
          'cd landing-page && cat > index.html << EOF\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>AI Service Landing Page</title>\n    <link rel="stylesheet" href="assets/css/styles.css">\n</head>\n<body>\n    <header>\n        <h1>Advanced AI Service</h1>\n        <p>Transforming business with autonomous intelligence</p>\n    </header>\n    <main>\n        <section id="features">\n            <h2>Key Features</h2>\n            <div class="feature-grid">\n                <div class="feature">Real-time Processing</div>\n                <div class="feature">24/7 Availability</div>\n                <div class="feature">Scalable Infrastructure</div>\n            </div>\n        </section>\n        <section id="contact">\n            <h2>Contact Us</h2>\n            <form id="contact-form">\n                <input type="email" placeholder="Email" required>\n                <textarea placeholder="Message" required></textarea>\n                <button type="submit">Send Message</button>\n            </form>\n        </section>\n    </main>\n</body>\n</html>\nEOF'
        ],
        dependencies: [],
        status: 'pending',
        estimatedDuration: 60000
      };

      const task2 = {
        id: uuidv4(),
        title: 'Style landing page with modern design',
        description: 'Apply responsive CSS styling with modern design patterns',
        assignedAgent: 'Pixel',
        commands: [
          'cd landing-page/assets/css && cat > styles.css << EOF\n* { margin: 0; padding: 0; box-sizing: border-box; }\nbody { font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; }\nheader { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 80px 20px; text-align: center; }\nheader h1 { font-size: 3em; margin-bottom: 20px; }\nheader p { font-size: 1.2em; opacity: 0.9; }\n.feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 30px; padding: 60px 20px; }\n.feature { background: white; padding: 30px; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }\n#contact { background: #f8f9fa; padding: 60px 20px; }\n#contact-form { max-width: 500px; margin: 0 auto; }\n#contact-form input, #contact-form textarea { width: 100%; padding: 15px; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px; }\n#contact-form button { background: #667eea; color: white; padding: 15px 30px; border: none; border-radius: 5px; cursor: pointer; }\nEOF'
        ],
        dependencies: [task1.id],
        status: 'pending',
        estimatedDuration: 45000
      };

      tasks.push(task1, task2);

    } else {
      // Generic workflow for other directives
  // Special-case: brainstorm / idea generation directives
  const lowerDir = directive.toLowerCase();
  // Debug log - detect directive content
  console.log('[WORKFLOW] decomposeDirective received directive:', directive);
  // Match patterns like "bring me 3 ideas", "bring me ideas", or "brainstorm"
  const isBrainstorm = (/bring\s+me/i.test(directive) && /idea/i.test(directive)) || /\bbrainstorm\b/i.test(directive);
  if (isBrainstorm) console.log('[WORKFLOW] Brainstorm intent detected for directive');
  if (isBrainstorm) {
        // Create a short plan where Alex coordinates and each agent provides N unique ideas
        const countMatch = directive.match(/(\d+)\s*(ideas|idea)/i);
  let ideaCount = countMatch ? parseInt(countMatch[1], 10) : 5; // default 5 ideas
  // Enforce sensible bounds to avoid runaway LLM usage
  const MAX_IDEAS_PER_AGENT = 10;
  if (isNaN(ideaCount) || ideaCount < 1) ideaCount = 1;
  if (ideaCount > MAX_IDEAS_PER_AGENT) ideaCount = MAX_IDEAS_PER_AGENT;

        const planningTask = {
          id: uuidv4(),
          title: 'Brainstorm planning and brief creation',
          description: `Alex will create a short coordinating brief for idea generation: "${directive}"`,
          assignedAgent: 'Alex',
          commands: [ `echo "Brief for brainstorming: ${directive}" > brainstorm-brief.txt` ],
          dependencies: [],
          status: 'pending',
          estimatedDuration: 8000
        };

        tasks.push(planningTask);

        // Define agent-specific focus areas to encourage unique outputs
        const perAgentPrompts = {
          'Nova': 'Focus on frontend/product experience ideas (UI, features, user flows)',
          'Pixel': 'Focus on visual and branding ideas (layouts, imagery, themes)',
          'Zephyr': 'Focus on backend/features/architecture ideas (scalability, integrations)',
          'Cipher': 'Focus on security/privacy/trust ideas (privacy-by-design, threat models)',
          'Sage': 'Focus on operations/DevOps/deployment ideas (observability, CI/CD)',
          'Ivy': 'Focus on messaging/documentation/positioning ideas (taglines, content angles)'
        };

  // Create one idea-generation task per registered agent in suggestedAgents or default roster
  const defaultAgentRoster = ['Alex','Nova','Pixel','Zephyr','Cipher','Sage','Ivy'];
  const agentList = (briefContext && briefContext.suggestedAgents && briefContext.suggestedAgents.length) ? briefContext.suggestedAgents : defaultAgentRoster;

        for (const agentName of agentList) {
          // Skip Alex for idea-producing tasks if desired (Alex coordinates)
          if (agentName === 'Alex') continue;

          const prompt = `Generate ${ideaCount} unique, numbered ideas about: ${directive}. ${perAgentPrompts[agentName] || ''} Provide short, actionable bullets and 1-sentence rationale for each idea.`;

          const ideaTask = {
            id: uuidv4(),
            title: `Brainstorm ideas (${agentName})`,
            description: `Ask ${agentName} to produce ${ideaCount} unique ideas for: ${directive}`,
            assignedAgent: agentName,
            type: 'ai_task',
            prompt,
            commands: [],
            dependencies: [planningTask.id],
            status: 'pending',
            estimatedDuration: 15000
          };

          tasks.push(ideaTask);
        }

        return tasks;
      }
      console.log('[WORKFLOW] Brainstorm branch not taken, proceeding to generic fallback');
      const task1 = {
        id: uuidv4(),
        title: 'Analyze and plan directive',
        description: `Create execution plan for: "${directive}"`,
        assignedAgent: 'Alex',
        commands: [
          'mkdir -p general-project',
          `echo "Project Plan\\n=============\\n\\nDirective: ${directive}\\n\\nThis project will be executed according to the specified requirements." > general-project/project-plan.md`,
          'echo "Directive analysis completed successfully"'
        ],
        dependencies: [],
        status: 'pending',
        estimatedDuration: 30000
      };

      const task2 = {
        id: uuidv4(),
        title: 'Execute directive requirements',
        description: 'Implement the core functionality as specified',
        assignedAgent: 'Nova',
        commands: [
          'cd ../alex-workspace/general-project && echo "Implementation started" > execution.log',
          'cd ../alex-workspace/general-project && sleep 5', // Simulate work  
          'cd ../alex-workspace/general-project && echo "Core functionality implemented" >> execution.log'
        ],
        dependencies: [task1.id], // Now this will have the correct ID
        status: 'pending',
        estimatedDuration: 60000
      };

      tasks.push(task1, task2);
    }

    // If the brief requested a specific agent explicitly, prefer that agent
    // for artifact-producing tasks to honor "no silent substitution" policy.
    try {
      if (briefContext && briefContext.agentExplicit && briefContext.requestedAgent) {
        const requested = briefContext.requestedAgent;
        // We consider a task to be artifact-producing if its commands create files
        const fileCreatePattern = /cat\s*>|echo\s+".*">|>\s*\w|touch\s+|npm run build|npm run build|npm build|echo\s+'.*'>/i;

        for (const t of tasks) {
          const isAlreadyRequested = (t.assignedAgent === requested);
          const hasCommands = Array.isArray(t.commands) && t.commands.length > 0;
          const createsFiles = hasCommands && t.commands.some(c => fileCreatePattern.test(c));

          if (!isAlreadyRequested && createsFiles) {
            // Annotate original assignment
            t.originalAssignedAgent = t.assignedAgent;
            t.forcedAssignmentReason = `Requested agent ${requested} explicitly in brief`;
            t.assignedAgent = requested;
            // Record an assumption in the task metadata for traceability
            t.assumptions = t.assumptions || [];
            t.assumptions.push(`Assigned to requested agent ${requested} per brief`);
          }
        }
      }
    } catch (err) {
      console.warn('Failed to enforce explicit agent assignment in decomposeDirective:', err.message);
    }

    return tasks;
  }

  // Specialized workflow creation methods for different project types
  createWebsiteWorkflow(directive, briefContext) {
    const tasks = [];
    const scope = briefContext?.scope || 'Basic prototype/MVP';
    const keyFeatures = briefContext?.keyFeatures || [];
    const targetUsers = briefContext?.targetUsers || 'General public';
    
    console.log(`[WORKFLOW] Creating website workflow - Scope: ${scope}, Features: ${keyFeatures.join(', ')}`);

    // Planning task
    const planningTask = {
      id: uuidv4(),
      title: 'Project planning and architecture',
      description: `Plan website for ${targetUsers} with scope: ${scope}`,
      assignedAgent: 'Alex',
      commands: [
        'mkdir -p kitten-rescue-website',
        `echo "# Kitten Rescue Website\\n\\nTarget Users: ${targetUsers}\\nScope: ${scope}\\nFeatures: ${keyFeatures.join(', ')}" > kitten-rescue-website/project-brief.md`
      ],
      dependencies: [],
      status: 'pending',
      estimatedDuration: scope.includes('Production') ? 60000 : 30000
    };

    // Design task  
    const designTask = {
      id: uuidv4(),
      title: 'Visual design and user experience',
      description: 'Create responsive design optimized for pet adoption',
      assignedAgent: 'Pixel',
      commands: [
        'cd kitten-rescue-website && mkdir -p assets/css assets/images',
        `echo "/* Kitten Rescue Styling - ${targetUsers} focused design */" > kitten-rescue-website/assets/css/styles.css`
      ],
      dependencies: [planningTask.id],
      status: 'pending',
      estimatedDuration: scope.includes('Full-featured') ? 90000 : 45000
    };

    // Frontend development
    const frontendTask = {
      id: uuidv4(),
      title: 'Frontend implementation',
      description: 'Build responsive HTML/CSS/JS website',
      assignedAgent: 'Nova',
      commands: [
        'cd kitten-rescue-website && cat > index.html << EOF\\n<!DOCTYPE html>\\n<html lang="en">\\n<head><meta charset="UTF-8"><title>Kitten Rescue</title></head>\\n<body><h1>Find Your Furry Friend</h1></body>\\n</html>\\nEOF'
      ],
      dependencies: [designTask.id],
      status: 'pending',
      estimatedDuration: scope.includes('Production') ? 120000 : 80000
    };

    tasks.push(planningTask, designTask, frontendTask);

    // Add conditional tasks based on features
    if (keyFeatures.includes('Donation system')) {
      const donationTask = {
        id: uuidv4(),
        title: 'Implement donation system',
        description: 'Add secure donation functionality',
        assignedAgent: 'Zephyr',
        dependencies: [frontendTask.id],
        status: 'pending',
        estimatedDuration: 90000
      };
      tasks.push(donationTask);
    }

    return tasks;
  }

  createDashboardWorkflow(directive, briefContext) {
    const tasks = [];
    const scope = briefContext?.scope || 'Basic prototype/MVP';
    
    console.log(`[WORKFLOW] Creating dashboard workflow - Scope: ${scope}`);

    // Planning
    const planningTask = {
      id: uuidv4(),
      title: 'Dashboard architecture planning',
      description: 'Design real-time dashboard architecture',
      assignedAgent: 'Alex',
      commands: [
        'mkdir -p dashboard-project/src/components dashboard-project/public',
        'cd dashboard-project && npm init -y'
      ],
      dependencies: [],
      status: 'pending',
      estimatedDuration: 45000
    };

    // Backend API
    const backendTask = {
      id: uuidv4(),
      title: 'Build dashboard API',
      description: 'Create metrics API and real-time data endpoints',
      assignedAgent: 'Zephyr',
      commands: [
        'cd dashboard-project && mkdir -p api',
        'cd dashboard-project/api && echo "const express = require(\'express\');" > server.js'
      ],
      dependencies: [planningTask.id],
      status: 'pending',
      estimatedDuration: scope.includes('Production') ? 150000 : 90000
    };

    // Frontend dashboard
    const frontendTask = {
      id: uuidv4(),
      title: 'Build React dashboard',
      description: 'Implement interactive dashboard with real-time updates',
      assignedAgent: 'Nova',
      dependencies: [backendTask.id],
      status: 'pending',
      estimatedDuration: scope.includes('Full-featured') ? 180000 : 120000
    };

    tasks.push(planningTask, backendTask, frontendTask);
    return tasks;
  }

  createFullstackWorkflow(directive, briefContext) {
    const tasks = [];
    const scope = briefContext?.scope || 'Basic prototype/MVP';
    const keyFeatures = briefContext?.keyFeatures || [];
    
    console.log(`[WORKFLOW] Creating fullstack workflow - Scope: ${scope}`);

    // All agents needed for fullstack
    const planningTask = {
      id: uuidv4(),
      title: 'Fullstack architecture planning',
      assignedAgent: 'Alex',
      dependencies: [],
      status: 'pending',
      estimatedDuration: 60000
    };

    const designTask = {
      id: uuidv4(),
      title: 'UI/UX design system',
      assignedAgent: 'Pixel',
      dependencies: [planningTask.id],
      status: 'pending',
      estimatedDuration: 90000
    };

    const backendTask = {
      id: uuidv4(),
      title: 'Backend API development',
      assignedAgent: 'Zephyr',
      dependencies: [planningTask.id],
      status: 'pending',
      estimatedDuration: 180000
    };

    const frontendTask = {
      id: uuidv4(),
      title: 'Frontend application',
      assignedAgent: 'Nova',
      dependencies: [designTask.id, backendTask.id],
      status: 'pending',
      estimatedDuration: 150000
    };

    const securityTask = {
      id: uuidv4(),
      title: 'Security implementation',
      assignedAgent: 'Cipher',
      dependencies: [backendTask.id],
      status: 'pending',
      estimatedDuration: 75000
    };

    const deploymentTask = {
      id: uuidv4(),
      title: 'Production deployment',
      assignedAgent: 'Sage',
      dependencies: [frontendTask.id, securityTask.id],
      status: 'pending',
      estimatedDuration: 90000
    };

    tasks.push(planningTask, designTask, backendTask, frontendTask, securityTask, deploymentTask);
    return tasks;
  }

  calculateTimeEstimates(tasks) {
    let totalEstimate = 0;
    let availableAgents = 0;
    const agentTasks = new Map();

    // Calculate per-agent workload
    for (const task of tasks) {
      const agent = this.agents.get(task.assignedAgent);
      if (agent && agent.availability === 'available') {
        if (!agentTasks.has(task.assignedAgent)) {
          agentTasks.set(task.assignedAgent, []);
          availableAgents++;
        }
        agentTasks.get(task.assignedAgent).push(task);
      }
    }

    // Calculate sequential vs parallel execution
    let maxAgentTime = 0;
    const agentEstimates = [];

    for (const [agentName, agentTaskList] of agentTasks) {
      const agent = this.agents.get(agentName);
      let agentTime = agent.queueDepth * agent.averageTaskTime; // Current queue
      
      for (const task of agentTaskList) {
        agentTime += task.estimatedDuration;
      }
      
      agentEstimates.push({
        agent: agentName,
        taskCount: agentTaskList.length,
        estimatedTime: agentTime,
        availability: agent.availability
      });

      maxAgentTime = Math.max(maxAgentTime, agentTime);
    }

    // Calculate total sequential estimate
    for (const task of tasks) {
      totalEstimate += task.estimatedDuration;
    }

    return {
      totalSequential: totalEstimate,
      estimatedParallel: maxAgentTime,
      availableAgents,
      agentBreakdown: agentEstimates,
      explanation: `Estimated ${Math.round(maxAgentTime / 1000 / 60)} minutes because ${availableAgents} agents are available and tasks can run in parallel. Longest chain: ${Math.round(maxAgentTime / 1000)}s.`
    };
  }

  queueTasks(tasks, workflowId) {
    for (const task of tasks) {
      task.workflowId = workflowId;
      this.taskQueue.push(task);
      
      const agent = this.agents.get(task.assignedAgent);
      if (agent) {
        agent.queueDepth++;
      }
    }

    console.log(`[WORKFLOW:${workflowId}] Queued ${tasks.length} tasks for execution`);
  }

  startWorkflowProcessor() {
    setInterval(async () => {
      await this.processNextTask();
    }, 1000); // Check every second

    console.log('âœ… Workflow processor started');
  }

  async processNextTask() {
    if (this.taskQueue.length === 0) return;

    // Find next ready task (dependencies satisfied, agent available)
    const readyTaskIndex = this.taskQueue.findIndex(task => {
      const agent = this.agents.get(task.assignedAgent);
      if (!agent || agent.executor.status !== 'idle') return false;

      // Check dependencies
      if (task.dependencies && task.dependencies.length > 0) {
        const workflow = this.workflows.get(task.workflowId);
        const completedTaskIds = workflow.tasks
          .filter(t => t.status === 'completed')
          .map(t => t.id);

        return task.dependencies.every(depId => completedTaskIds.includes(depId));
      }

      return true;
    });

    if (readyTaskIndex === -1) return;

    // Execute the ready task
    const task = this.taskQueue.splice(readyTaskIndex, 1)[0];
    const agent = this.agents.get(task.assignedAgent);
    
    if (agent) {
      agent.queueDepth = Math.max(0, agent.queueDepth - 1);
      await this.executeTask(task, agent);
    }
  }

  async executeTask(task, agent) {
    const workflow = this.workflows.get(task.workflowId);
    
    // Update task status in workflow
    const workflowTask = workflow.tasks.find(t => t.id === task.id);
    if (workflowTask) {
      workflowTask.status = 'running';
      workflowTask.startTime = Date.now();
    }

    // Update workflow progress
    this.updateWorkflowProgress(task.workflowId);

    try {
      let results;

      // If this is a manager review task, perform a lightweight review step instead of shell commands
      if (task.type === 'manager_review') {
        this.streamToConsole = this.streamToConsole || console.log;
        agent.executor.streamToConsole && agent.executor.streamToConsole(`[${agent.config.name}] Starting manager review for workflow ${workflow.id}`);
        const artifactsCount = (workflow.artifacts && workflow.artifacts.length) || 0;
        this.streamToConsole && this.streamToConsole(`[${agent.config.name}] Manager reviewing ${artifactsCount} artifacts`);

        results = {
          taskId: task.id,
          agentName: agent.config.name,
          startTime: Date.now(),
          endTime: Date.now(),
          steps: [],
          artifacts: [],
          status: 'completed'
        };
      }

      // If this is a structured create_file task or a manager_brief, invoke the executor's createFile directly
      else if (task.type === 'create_file' || task.type === 'manager_brief') {
        this.streamToConsole = this.streamToConsole || console.log;
        agent.executor.streamToConsole(`[${agent.config.name}] Creating file ${task.fileName} as part of workflow ${task.workflowId}`);

        const artifact = await agent.executor.createFile(task.fileName, task.content || '');

        // Normalize artifact fields to match lineage expectations
        const normalized = Object.assign({}, artifact);
        const fileName = normalized.name || normalized.path || normalized.fileName || normalized.file || (normalized.fullPath ? require('path').basename(normalized.fullPath) : task.fileName);
        normalized.name = fileName;
        // Ensure checksum key is present for downstream lineage (some modules use 'checksum', others 'sha256')
        normalized.checksum = normalized.checksum || normalized.sha256 || normalized.sha || '';

        results = {
          taskId: task.id,
          agentName: agent.config.name,
          startTime: Date.now(),
          endTime: Date.now(),
          steps: [],
          artifacts: [normalized],
          status: 'completed'
        };
      } else {
        results = await agent.executor.executeTask(
          task.id,
          task.description,
          task.commands
        );
      }

      // Update task with results
      if (workflowTask) {
        workflowTask.status = results.status === 'completed' ? 'completed' : 'failed';
        workflowTask.endTime = Date.now();
        workflowTask.actualDuration = workflowTask.endTime - workflowTask.startTime;
        workflowTask.results = results;
      }

      // Collect and track artifacts with full lineage
      const artifacts = agent.executor.getArtifacts();
      await this.trackTaskArtifacts(task, artifacts, workflow);

      // Update workflow progress
      this.updateWorkflowProgress(task.workflowId);

      console.log(`[WORKFLOW:${task.workflowId}] Task ${task.title} ${results.status} by ${agent.config.name}`);

    } catch (error) {
      console.error(`[WORKFLOW:${task.workflowId}] Task ${task.title} failed:`, error);
      
      if (workflowTask) {
        workflowTask.status = 'failed';
        workflowTask.error = error.message;
      }

      this.updateWorkflowProgress(task.workflowId);
    }
  }

  async updateWorkflowProgress(workflowId) {
    const workflow = this.workflows.get(workflowId);
    if (!workflow) return;

    const completed = workflow.tasks.filter(t => t.status === 'completed').length;
    const failed = workflow.tasks.filter(t => t.status === 'failed').length;
    const total = workflow.tasks.length;

    workflow.progress = {
      completed,
      failed,
      total,
      percentage: Math.round((completed / total) * 100)
    };

    // Check if workflow is complete
    if (completed + failed === total) {
      // If workflow requires manager approval/CEO sign-off, ensure both have occurred before marking completed
      const requiresManagerApproval = !!workflow.metadata && !!workflow.metadata.requiresManagerApproval;
      const managerReviewDone = workflow.tasks.some(t => t.type === 'manager_review' && t.status === 'completed');
      const ceoApproved = !!(workflow.metadata && workflow.metadata.ceoApproved);

      if (requiresManagerApproval && !(managerReviewDone && ceoApproved)) {
        // Mark as waiting for final approval rather than completed
        workflow.status = 'waiting_for_ceo_approval';
        console.log(`[WORKFLOW:${workflowId}] Waiting for manager review and CEO approval before finalizing`);
      } else {
        workflow.status = failed > 0 ? 'failed' : 'completed';
        workflow.endTime = Date.now();
        workflow.totalDuration = workflow.endTime - workflow.startTime;

        this.completedWorkflows.push(workflow);
        console.log(`[WORKFLOW:${workflowId}] Workflow ${workflow.status} in ${Math.round(workflow.totalDuration / 1000)}s`);
      }
    }

    // Update database
    try {
      await Workflow.update({
        status: workflow.status,
        end_time: workflow.endTime ? new Date(workflow.endTime) : null,
        total_duration: workflow.totalDuration,
        tasks: workflow.tasks,
        progress: workflow.progress,
        artifacts: workflow.artifacts
      }, {
        where: { id: workflowId }
      });
      
      console.log(`[WORKFLOW:${workflowId}] Database updated - Progress: ${workflow.progress.percentage}%`);
    } catch (error) {
      console.error(`[WORKFLOW:${workflowId}] Failed to update database:`, error);
    }

    // Emit progress update (guarded)
    if (this.socketio && typeof this.socketio.emit === 'function') {
      this.socketio.emit('workflow-progress', {
      workflowId,
      progress: workflow.progress,
      status: workflow.status,
      tasks: workflow.tasks.map(t => ({
        id: t.id,
        title: t.title,
        status: t.status,
        assignedAgent: t.assignedAgent,
        actualDuration: t.actualDuration
      })),
      artifacts: workflow.artifacts.length
      });
    } else {
      console.log(`[WORKFLOW:${workflowId}] socketio not available, skipping workflow-progress emit`);
    }
  }

  getHistoricalAverage(agentName) {
    // TODO: Load from database - for now return reasonable defaults
    const averages = {
      'Alex': 35000,    // 35 seconds for planning tasks
      'Nova': 90000,    // 90 seconds for frontend tasks  
      'Zephyr': 120000, // 120 seconds for backend tasks
      'Pixel': 60000,   // 60 seconds for design tasks
      'Cipher': 45000,  // 45 seconds for security tasks
      'Sage': 75000     // 75 seconds for deployment tasks
    };

    return averages[agentName] || 60000;
  }

  // Choose manager based on briefContext, suggestedAgents, and simple capability matching
  selectManagerForDirective(directive, briefContext = {}) {
    // Prefer explicit requested agent from briefContext
    if (briefContext && briefContext.requestedAgent && briefContext.requestedAgent !== '') {
      return briefContext.requestedAgent;
    }

    // Heuristic: DevOps/backend -> Sage, backend-heavy -> Zephyr, design -> Pixel, docs/content -> Nova/Ivy, otherwise Alex
    const lower = (directive || '').toLowerCase();
    if (lower.includes('ci') || lower.includes('deploy') || lower.includes('infrastructure') || lower.includes('ci/cd')) return 'Sage';
    if (lower.includes('api') || lower.includes('backend') || lower.includes('server')) return 'Zephyr';
    if (lower.includes('design') || lower.includes('branding') || lower.includes('visual')) return 'Pixel';
    if (lower.includes('about me') || lower.includes('.md') || lower.includes('markdown') || lower.includes('document')) return 'Sage';
    if (lower.includes('ideas') || lower.includes('brainstorm') || lower.includes('movie') || lower.includes('pitch')) return 'Alex';

    // fallback: choose the first suggested agent if present
    if (briefContext && Array.isArray(briefContext.suggestedAgents) && briefContext.suggestedAgents.length > 0) return briefContext.suggestedAgents[0];

    return 'Alex';
  }

  // When a manager brief has been approved, schedule pending tasks stored on workflow
  async schedulePendingAfterApproval(workflowId) {
    const workflow = this.workflows.get(workflowId);
    if (!workflow || !workflow._pendingAfterApproval || workflow._pendingAfterApproval.length === 0) return 0;

    const pending = workflow._pendingAfterApproval;
    // Attach a manager_review task at the end that managers must complete for final sign-off
    const managerReviewTask = {
      id: uuidv4(),
      title: 'Manager Review & Sign-off',
      description: 'Manager reviews delivered artifacts vs. brief and signs off to complete the workflow',
      assignedAgent: workflow.manager || 'Alex',
      type: 'manager_review',
      dependencies: pending.map(t => t.id),
      status: 'pending',
      estimatedDuration: 8000
    };

  // Append manager review to pending tasks if not already present
  const hasReview = pending.some(t => t.type === 'manager_review');
  if (!hasReview) pending.push(managerReviewTask);

    // Add to workflow tasks and queue them
    workflow.tasks = workflow.tasks.concat(pending);
    workflow.progress.total = workflow.tasks.length;
    delete workflow._pendingAfterApproval;

    // Persist updated tasks to DB immediately
    try {
      await Workflow.update({ tasks: workflow.tasks, progress: workflow.progress }, { where: { id: workflowId } }).catch(() => null);
    } catch (e) {
      console.warn('[WORKFLOW] schedulePendingAfterApproval DB update failed:', e && e.message);
    }

    this.queueTasks(pending, workflowId);
    console.log(`[WORKFLOW:${workflowId}] Scheduled ${pending.length} pending tasks after manager approval`);
    return pending.length;
  }

  // Record CEO approval/rejection for a workflow - affects final completion
  async recordCeoApproval(workflowId, approver = 'ceo', approved = true) {
    const workflow = this.workflows.get(workflowId);
    if (!workflow) throw new Error('Workflow not found');

    workflow.metadata = workflow.metadata || {};
    workflow.metadata.ceoApproved = !!approved;
    workflow.metadata.ceoApprover = approver;
    workflow.metadata.ceoApprovedAt = new Date();

    try {
      await Workflow.update({ metadata: workflow.metadata }, { where: { id: workflowId } }).catch(() => null);
    } catch (e) {
      console.warn('[WORKFLOW] recordCeoApproval DB update failed:', e && e.message);
    }

    // Re-evaluate workflow completion state
    await this.updateWorkflowProgress(workflowId);

    return { workflowId, ceoApproved: workflow.metadata.ceoApproved };
  }

  // External call to notify orchestrator that a brief has been approved and attach manager metadata
  async attachBriefApproval(workflowId, briefCompleted) {
    const workflow = this.workflows.get(workflowId);
    if (!workflow) throw new Error('Workflow not found');

    // Set manager based on briefCompleted.requestedAgent or select heuristically
    const manager = briefCompleted.requestedAgent || this.selectManagerForDirective(workflow.directive, briefCompleted);
    workflow.manager = manager;
    workflow.brief = briefCompleted;

    // Persist manager metadata
    try {
      await Workflow.update({ metadata: Object.assign({}, workflow.metadata || {}, { manager }) }, { where: { id: workflowId } }).catch(() => null);
    } catch (e) {
      console.warn('[WORKFLOW] attachBriefApproval failed to persist manager metadata:', e && e.message);
    }

    // Schedule pending tasks that were paused
    const scheduled = await this.schedulePendingAfterApproval(workflowId);
    return { scheduled, manager };
  }

  getAgentStatus() {
    const status = [];
    for (const [name, agent] of this.agents) {
      status.push({
        name,
        role: agent.config.role,
        status: agent.executor.status,
        queueDepth: agent.queueDepth,
        currentTask: agent.executor.currentTask,
        artifacts: agent.executor.artifacts.length,
        specializations: agent.config.specializations
      });
    }
    return status;
  }

  async shutdown() {
    // Clear intervals started by this orchestrator
    try {
      if (this.artifactReconcilerInterval) clearInterval(this.artifactReconcilerInterval);
      if (this.workflowProcessorInterval) clearInterval(this.workflowProcessorInterval);
    } catch (e) {
      // ignore
    }

    // Stop agent executors if present
    for (const [name, agent] of this.agents) {
      try {
        if (agent && agent.executor && typeof agent.executor.shutdown === 'function') {
          await agent.executor.shutdown();
        }
      } catch (e) {
        // ignore
      }
    }

    console.log('âœ… WorkflowOrchestrator shutdown complete');
  }

  getWorkflowStatus(workflowId) {
    return this.workflows.get(workflowId);
  }

  async getAllWorkflows() {
    try {
      // Load from database
      const dbWorkflows = await Workflow.findAll({
        order: [['start_time', 'DESC']]
      });

      // Convert database records to workflow objects
      const workflows = dbWorkflows.map(dbWorkflow => ({
        id: dbWorkflow.id,
        directive: dbWorkflow.directive,
        status: dbWorkflow.status,
        startTime: dbWorkflow.start_time.getTime(),
        endTime: dbWorkflow.end_time ? dbWorkflow.end_time.getTime() : null,
        totalDuration: dbWorkflow.total_duration,
        tasks: dbWorkflow.tasks || [],
        estimates: dbWorkflow.estimates || {},
        progress: dbWorkflow.progress || { completed: 0, total: 0, percentage: 0 },
        artifacts: dbWorkflow.artifacts || []
      }));

      console.log(`[WORKFLOWS] Loaded ${workflows.length} workflows from database`);
      return workflows;
    } catch (error) {
      console.error('Failed to load workflows from database:', error);
      return Array.from(this.workflows.values());
    }
  }

  async downloadArtifact(agentName, artifactId) {
    const agent = this.agents.get(agentName);
    if (!agent) {
      throw new Error(`Agent ${agentName} not found`);
    }

    return await agent.executor.downloadArtifact(artifactId);
  }

  // =====================================================
  // ARTIFACT LINEAGE TRACKING METHODS (PHASE 3)
  // =====================================================

  /**
   * Track artifacts created by task execution with full lineage
   */
  async trackTaskArtifacts(task, artifacts, workflow) {
    try {
      for (const artifact of artifacts) {
        const lineageData = {
          name: artifact.name,
          workflowId: workflow.id,
          taskId: task.id,
          agentName: task.assignedAgent,
          directive: workflow.directive,
          taskTitle: task.title,
          creationReason: `Task execution: ${task.description}`,
          fileSize: artifact.size || 0,
          fileType: artifact.type || this.getFileType(artifact.name),
          encoding: artifact.encoding || 'utf8',
          checksum: artifact.checksum,
          relativePath: artifact.relativePath,
          absolutePath: artifact.absolutePath,
          content: artifact.content || '',
          parentArtifacts: artifact.parentArtifacts || []
        };

        // Ensure absolute path points to agent workspace artifacts directory when possible
        try {
          const workspaceManager = require('./workspace-manager');
          const agentWorkspace = await workspaceManager.ensureAgentWorkspace(task.assignedAgent.toLowerCase());
          // If artifact provided an absolute path, leave it. Otherwise, compute a standardized artifacts path.
          if (!lineageData.absolutePath || lineageData.absolutePath === '') {
            const artifactsDir = require('path').join(agentWorkspace, 'artifacts');
            const nameSafe = artifact.name.replace(/[^a-zA-Z0-9._-]/g, '_');
            const targetPath = require('path').join(artifactsDir, nameSafe);
            lineageData.absolutePath = targetPath;
            lineageData.relativePath = `artifacts/${nameSafe}`;
          }

        } catch (e) {
          // workspace manager might not be available in some test contexts, proceed without failing
          console.warn('[LINEAGE] workspace-manager not available for artifact path resolution:', e.message);
        }

        // If checksum not provided, try to compute from file
        try {
          if ((!lineageData.checksum || lineageData.checksum === '') && lineageData.absolutePath) {
            try {
              const fileBuf = await fs.readFile(lineageData.absolutePath);
              const sum = crypto.createHash('sha256').update(fileBuf).digest('hex');
              lineageData.checksum = sum;
              lineageData.fileSize = fileBuf.length;
            } catch (e) {
              // Could not read file to compute checksum; proceed without it
              console.warn('[LINEAGE] Could not compute checksum for', lineageData.absolutePath, e.message);
            }
          }
        } catch (e) {
          console.warn('[LINEAGE] checksum computation failed:', e.message);
        }

        const trackedArtifact = await this.artifactLineage.recordArtifact(lineageData);

        // Persist artifact metadata to DB if model available
        try {
          if (Artifact) {
            // Ensure the workflow record exists in DB before creating a FK reference
            const existingWorkflow = await Workflow.findByPk(workflow.id).catch(() => null);
            if (!existingWorkflow) {
              console.warn('[DB] Workflow record not found for artifact persist, skipping DB create for', lineageData.name || lineageData.relativePath || lineageData.absolutePath);
            } else {
              // Resolve project id (prefer workflow metadata, else fallback/create)
              let projectId = null;
              const workflowRow = await Workflow.findByPk(workflow.id).catch(() => null);
              if (workflowRow && workflowRow.metadata && workflowRow.metadata.project_id) projectId = workflowRow.metadata.project_id;
              if (!projectId) {
                let p = await Project.findOne().catch(() => null);
                if (!p) {
                  p = await Project.create({ name: 'Autogenerated', description: 'Auto project for artifact persistence', owner_id: 1, status: 'active' });
                }
                projectId = p && p.id ? p.id : null;
              }

              const sha = lineageData.checksum || (artifact.checksum || '');

              if (!sha || sha.length === 0) {
                // Defer persistence until checksum available
                console.warn('[DB] Artifact checksum missing, deferring persist for later reconciliation:', lineageData.absolutePath || lineageData.relativePath || artifact.name);
                this.pendingArtifactPersist = this.pendingArtifactPersist || [];
                this.pendingArtifactPersist.push({ workflowId: workflow.id, lineageData, trackedArtifactId: trackedArtifact.id });
              } else {
                try {
                  const createdArtifact = await Artifact.create({
                    project_id: projectId || workflow.id,
                    path: lineageData.relativePath || lineageData.absolutePath || artifact.name,
                    sha256: sha,
                    bytes: lineageData.fileSize || (artifact.size || 0),
                    produced_by_task: task.id
                  });
                  // record DB artifact id on the tracked artifact entry
                  if (createdArtifact && createdArtifact.id) {
                    // attach DB id into the stored lineage record if possible
                    trackedArtifact.dbArtifactId = createdArtifact.id;
                    // Also update workflow.artifacts entry so UI can link directly
                    try {
                      const wfArtifacts = workflow.artifacts || [];
                      const entry = wfArtifacts.find(a => a.id === trackedArtifact.id || a.lineageId === trackedArtifact.id || a.trackedId === trackedArtifact.id);
                      if (entry) {
                        entry.dbArtifactId = createdArtifact.id;
                      } else {
                        wfArtifacts.push({ id: trackedArtifact.id, lineageId: trackedArtifact.id, dbArtifactId: createdArtifact.id });
                      }
                      // Persist updated artifacts list to DB
                      await Workflow.update({ artifacts: wfArtifacts }, { where: { id: workflow.id } }).catch(() => null);
                    } catch (uerr) {
                      console.warn('[DB] Failed to update workflow.artifacts after immediate create:', uerr && uerr.message);
                    }
                  }
                } catch (err) {
                  // Better debug logging for Sequelize errors
                  const dumpErr = (e) => {
                    try {
                      return JSON.stringify(e, Object.getOwnPropertyNames(e));
                    } catch (ex) {
                      return String(e);
                    }
                  };
                  console.warn('[DB] Artifact.create threw error:', err && err.name, err && err.message);
                  console.warn('[DB] Artifact.create error details:', dumpErr(err));
                  const msg = err && err.message && err.message.toLowerCase ? err.message.toLowerCase() : '';
                  const parentMsg = err && err.parent && err.parent.message && err.parent.message.toLowerCase ? err.parent.message.toLowerCase() : '';
                  const isUnique = (err && err.name === 'SequelizeUniqueConstraintError') || msg.includes('unique') || parentMsg.includes('unique');
                  const isFK = (err && err.name === 'SequelizeForeignKeyConstraintError') || msg.includes('foreign key') || parentMsg.includes('foreign key');

                  if (isUnique && sha) {
                    const existing = await Artifact.findOne({ where: { sha256: sha } }).catch(() => null);
                    if (existing) {
                      console.log('[DB] Artifact already exists with same checksum, linking existing artifact id', existing.id);
                      // attach DB id to trackedArtifact so UI/DB linkage is available
                      trackedArtifact.dbArtifactId = existing.id;
                    } else {
                      console.warn('[DB] Unique constraint violation but no existing artifact found for sha:', sha, 'deferring persist');
                      this.pendingArtifactPersist = this.pendingArtifactPersist || [];
                      this.pendingArtifactPersist.push({ workflowId: workflow.id, lineageData, trackedArtifactId: trackedArtifact.id });
                    }
                  } else if (isFK) {
                    console.warn('[DB] Artifact DB create failed (FK), deferring persist for later reconciliation:', err && err.message);
                    this.pendingArtifactPersist = this.pendingArtifactPersist || [];
                    this.pendingArtifactPersist.push({ workflowId: workflow.id, lineageData, trackedArtifactId: trackedArtifact.id });
                  } else {
                    console.warn('[DB] Artifact DB create failed, deferring persist for later reconciliation:', err && err.message);
                    this.pendingArtifactPersist = this.pendingArtifactPersist || [];
                    this.pendingArtifactPersist.push({ workflowId: workflow.id, lineageData, trackedArtifactId: trackedArtifact.id });
                  }
                }
              }
            }
          }
        } catch (e) {
          console.warn('[DB] Failed to persist artifact to DB (outer):', e && e.message);
        }

        // Add to workflow artifacts with lineage info
        workflow.artifacts.push({
          id: trackedArtifact.id,
          name: artifact.name,
          path: lineageData.relativePath || lineageData.absolutePath || artifact.path || artifact.fullPath,
          agentName: task.assignedAgent,
          taskId: task.id,
          createdAt: trackedArtifact.createdAt,
          lineage: trackedArtifact.lineage
        });

        console.log(`[LINEAGE] Tracked artifact: ${artifact.name} from ${task.assignedAgent} in workflow ${workflow.id}`);
      }
    } catch (error) {
      console.error('[LINEAGE] Failed to track artifacts:', error);
    }
  }

  /**
   * Update artifact when modified through agent environment
   */
  async updateArtifactLineage(agentName, fileName, newContent, modificationContext) {
    try {
      // Find artifact by agent and filename
    const agentArtifacts = this.artifactLineage.getAgentArtifacts(agentName);
      const artifact = agentArtifacts.find(a => a.name === fileName);
      
      if (artifact) {
        await this.artifactLineage.updateArtifact(artifact.id, { content: newContent }, {
          action: 'manual_edit',
          agentName: 'user',
          details: `File edited via ${agentName} agent environment`,
          ...modificationContext
        });
        
        // Emit update to connected clients
        if (this.socketio && typeof this.socketio.emit === 'function') {
          this.socketio.emit('artifact-updated', {
            artifactId: artifact.id,
            agentName,
            fileName,
            timestamp: new Date().toISOString(),
            action: 'edited'
          });
        } else {
          console.log('[LINEAGE] socketio not available, skipping artifact-updated emit');
        }

        console.log(`[LINEAGE] Updated artifact ${fileName} by user via ${agentName} environment`);
        return artifact.id;
      }
    } catch (error) {
      console.error('[LINEAGE] Failed to update artifact lineage:', error);
    }
    return null;
  }

  /**
   * Get artifact lineage for console/UI display
   */
  getArtifactLineage(artifactId) {
    return this.artifactLineage.getArtifactWithLineage(artifactId);
  }

  /**
   * Search artifacts across all workflows
   */
  searchArtifacts(criteria) {
    return this.artifactLineage.searchArtifacts(criteria);
  }

  /**
   * Get artifacts for a specific workflow with lineage
   */
  getWorkflowArtifactsWithLineage(workflowId) {
    const artifacts = this.artifactLineage.getWorkflowArtifacts(workflowId);
    return artifacts.map(artifact => this.artifactLineage.getArtifactWithLineage(artifact.id));
  }

  /**
   * Get artifacts for a specific agent with lineage
   */
  getAgentArtifactsWithLineage(agentName) {
    const artifacts = this.artifactLineage.getAgentArtifacts(agentName);
    return artifacts.map(artifact => this.artifactLineage.getArtifactWithLineage(artifact.id));
  }

  /**
   * Generate clickable lineage links for console display
   */
  generateArtifactLinks(artifactId) {
    return this.artifactLineage.generateLineageLinks(artifactId);
  }

  /**
   * Get comprehensive lineage report for debugging
   */
  getLineageReport() {
    return this.artifactLineage.getLineageReport();
  }

  /**
   * Determine file type from extension
   */
  getFileType(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const typeMap = {
      'js': 'javascript',
      'jsx': 'javascript', 
      'ts': 'typescript',
      'tsx': 'typescript',
      'html': 'html',
      'css': 'css',
      'json': 'json',
      'md': 'markdown',
      'txt': 'text',
      'py': 'python',
      'yml': 'yaml',
      'yaml': 'yaml'
    };
    return typeMap[ext] || 'unknown';
  }
}

module.exports = WorkflowOrchestrator;
